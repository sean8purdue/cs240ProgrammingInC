# Lab 1: Getting acquainted with C and its system environment 

Due: 06/20/2017 (Tue.), 11:59 PM

## Objective

The objective of this introductory lab is to familiarize you with the system environment of C programs under Linux.

## Reading

Read chapter 1 from Kernighan&Ritchie (textbook). The introduction provides an overview of C programming. It is a bit dense. You are not expected to understand all the material. What you need to understand is the material discussed in class, with the textbook serving as a supplementary resource.

## Lecture Notes

- What is CS 240 about? ([lec1] [lec1])
- C programs and their system environment (see class notes) (additional reference: [lec2][lec2])
	- C code and machine code ([pdf][machineCode])
	- Roles of C compiler, C preprocessor, assembler, linker, loader
	- Reading and writing to standard I/O

[lec1]:https://github.com/sean8purdue/cs240ProgrammingInC/blob/lab1/lab1/cs240crisn1.pdf
[lec2]:https://github.com/sean8purdue/cs240ProgrammingInC/blob/lab1/lab1/cs240crisn2.pdf
[machineCode]:https://github.com/sean8purdue/cs240ProgrammingInC/blob/lab1/lab1/cs240-park1.pdf

## Lab1 code base

The C code base for lab1 is available as a tarball at 

/u/data/u3/park/pub/cs240/lab1.tar 

on the Linux machines in LWSN B148. Copy it to your working directory and untar it using 

% tar xvf lab1.tar 

Under lab1, you will find 7 subdirectories that contain versions of the example code discussed in class. As noted in class, always compile and run the final version on the pod machines in LWSN 148.

## Problems [145 pts]

### Problem1 (20 pts)

Compile the code in directory v1 by running 

% gcc main.c 

What is the nature of the output a.out generated by gcc? What are the three steps performed by gcc that results in a.out? What does each of the steps accomplish? 

1. The a.out genertated by gcc is an object code, it's an unlinked machine code(binary file).
2. There are four steps gcc performed.
	- First, it runs the C preprocessor to pre-compile, ` $ gcc -Wall -E print.c`,output is **print.i** file.
		- expand all statements starting with #; 
		- Macro substitution;
		- Comments are stripped off 
	- Second, after the compiler is done with the pre-processor stage. The next step is to take print.i as input, compile it and produce an intermediate compiled output. The output file for this stage is ‘print.s’. The output present in print.s is assembly level instructions. output is **print.s** file. <br/><br/>
	- Third, at this stage the print.s file is taken as an input and an intermediate file print.o is produced. This file is also known as the object file. This file is produced by the assembler that understands and converts a ‘.s’ file with assembly instructions into a ‘.o’ object file which contains machine level instructions. <br/> At this stage only the existing code is converted into machine language, the function calls like printf() are not resolved. <br/><br/>
	- Fourth, Static Link and Dynamic Link. The linker comes into action at this stage and does this task. Generating a **executable file a.out**, or other programmer specified name. <br/> As discussed earlier, till this stage gcc doesn’t know about the definition of functions like printf(). Until the compiler knows exactly where all of these functions are implemented, it simply uses a place-holder for the function call. It is at this stage, the definition of printf() is resolved and the actual address of the function printf() is plugged in.

How does gcc react if you omit the type declaration of main()? Will gcc generate an executable? What happens if you declare main()'s type as void?

- If omit the type declaration of main(), gcc will give warning when compile. But still generate **a.out** file.

~~~bash
main.c:6:1: warning: type specifier missing, defaults to 'int'
      [-Wimplicit-int]
main()
^
~~~

- Delcare main() type as void, gcc warn:

~~~bash
main.c:6:1: warning: return type of 'main' is not 'int'
      [-Wmain-return-type]
void main()
^
main.c:6:1: note: change return type to 'int'
void main()
^~~~
int
1 warning generated.

~~~
