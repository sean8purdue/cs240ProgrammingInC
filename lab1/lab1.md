# Lab 1: Getting acquainted with C and its system environment 

Due: 06/20/2017 (Tue.), 11:59 PM

## Objective

The objective of this introductory lab is to familiarize you with the system environment of C programs under Linux.

## Reading

Read chapter 1 from Kernighan&Ritchie (textbook). The introduction provides an overview of C programming. It is a bit dense. You are not expected to understand all the material. What you need to understand is the material discussed in class, with the textbook serving as a supplementary resource.

## Lecture Notes

- What is CS 240 about? ([lec1] [lec1])
- C programs and their system environment (see class notes) (additional reference: [lec2][lec2])
	- C code and machine code ([pdf][machineCode])
	- Roles of C compiler, C preprocessor, assembler, linker, loader
	- Reading and writing to standard I/O

[lec1]:https://github.com/sean8purdue/cs240ProgrammingInC/blob/lab1/lab1/cs240crisn1.pdf
[lec2]:https://github.com/sean8purdue/cs240ProgrammingInC/blob/lab1/lab1/cs240crisn2.pdf
[machineCode]:https://github.com/sean8purdue/cs240ProgrammingInC/blob/lab1/lab1/cs240-park1.pdf

## Lab1 code base

The C code base for lab1 is available as a tarball at 

`/u/data/u3/park/pub/cs240/lab1.tar `

on the Linux machines in LWSN B148. Copy it to your working directory and untar it using 

`% tar xvf lab1.tar `

Under lab1, you will find 7 subdirectories that contain versions of the example code discussed in class. As noted in class, always compile and run the final version on the pod machines in LWSN 148.

## Problems [145 pts]

### Problem1 (20 pts)

Compile the code in directory v1 by running 

`% gcc main.c `

What is the nature of the output a.out generated by gcc? What are the three steps performed by gcc that results in a.out? What does each of the steps accomplish? [Refer:JourneyOfaCProgramToLinuxExecutable](https://github.com/sean8purdue/cs240ProgrammingInC/blob/dev/lab1/JourneyOfaCProgramToLinuxExecutable.pdf)

1. The a.out genertated by gcc is an object code, it's an unlinked machine code(binary file).
2. There are four steps gcc performed.
	- First, it runs the C preprocessor to pre-	compile, ,output is **print.i** file.
	
		`$ gcc -Wall -E print.c `
		- expand all statements starting with #; 
		- Macro substitution;
		- Comments are stripped off 
	- Second, after the compiler is done with the pre-processor stage. The next step is to take print.i as input, compile it and produce an intermediate compiled output. The output file for this stage is ‘print.s’. The output present in print.s is assembly level instructions. output is **print.s** file. <br/><br/>
	- Third, at this stage the print.s file is taken as an input and an intermediate file print.o is produced. This file is also known as the object file. This file is produced by the assembler that understands and converts a ‘.s’ file with assembly instructions into a ‘.o’ object file which contains machine level instructions. <br/> At this stage only the existing code is converted into machine language, the function calls like printf() are not resolved. <br/><br/>
	- Fourth, Static Link and Dynamic Link. The linker comes into action at this stage and does this task. Generating a **executable file a.out**, or other programmer specified name. <br/> As discussed earlier, till this stage gcc doesn’t know about the definition of functions like printf(). Until the compiler knows exactly where all of these functions are implemented, it simply uses a place-holder for the function call. It is at this stage, the definition of printf() is resolved and the actual address of the function printf() is plugged in.

How does gcc react if you omit the type declaration of main()? Will gcc generate an executable? What happens if you declare main()'s type as void?

1. If omit the type declaration of main(), gcc will give warning when compile. But still generate **a.out** file.

	~~~bash
	main.c:6:1: warning: type specifier missing, defaults to 	'int'
   	   [-Wimplicit-int]
		main()
	^
	~~~

2. Delcare main() type as void, gcc warn:

	~~~bash
main.c:6:1: warning: return type of 'main' is not 'int'
      [-Wmain-return-type]
void main()
^
main.c:6:1: note: change return type to 'int'
void main()
^~~~
int
1 warning generated.
	~~~
	
### Problem2 (20 pts)

The version in directory v2 is essentially the same as the one in v1 except that printing of the addition result is facilitated by the libary function printf(). printf() outputs to standard output which is, by default, the terminal (i.e., display or screen) associated with a PC in our lab.

Where is the header file stdio.h located on our Linux lab machines in LWSN B148? 

`/usr/include`

What part of "result of %d + %d is %d" is literal (just characters to be printed as is) and what part is reserved, i.e., part of formatting control of C that determines how content of a variable is output? What happens if you run gcc with option -c? Can you execute the output generated by gcc? Explain.

1. "result of  + is" will be printed as is. %d will print as the content of a variable.
2. if run `gcc -c main.c`, we can just get `main.o` object file, which is not linked up to a executable file, so we cannot run it.

### Problem3 (30 pts)

The version of v3 makes a further enhancement such that the two numbers to be added are provided as input via keyboard input which, by default, is the standard input of a Linux PC. What is the role of & (i.e., ampersand) in 

`scanf("%d %d",&x,&y) `

and why is 

`scanf("%d %d",x,y) `

incorrect? Compile the code as is, and run it to verify that it works correctly. Modify the code by removing the two ampersands and compile main.c using gcc. What does gcc say after the modification? What happens when you run a.out? Explain.


1. The role of `&` is to get the address of variable.

2. Because `scanf("%d %d", x, y)' the argument are pointers(which contents are address).

3. removing ampersands will have warning:

	~~~c
	main.c:17:17: warning: format specifies type 'int *' but 	the argument
      has type 'int' [-Wformat]
  	scanf("%d %d",x,y);
         ~~     ^
	main.c:17:19: warning: format specifies type 'int *' but 	the argument
  	    has type 'int' [-Wformat]
 	 scanf("%d %d",x,y);
            ~~    ^
	2 warnings generated.
	~~~ 
4. Run a.out will have SEG fault, because we try to write to the memory address, which is not belonged to our process a.out. We input 99932, `scanf()` will try to write 99932 to the address 0, which is the value of x in this case. Since x is not defined, x might be other garbage value.

	~~~bash
	➜  v3 git:(lab1) ✗ ./a.out
99932
[1]    26574 segmentation fault  ./a.out
	~~~
	
	print the initial value of x, in this runtime, x is 1.
5. s



