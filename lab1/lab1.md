# Lab 1: Getting acquainted with C and its system environment 

Due: 06/20/2017 (Tue.), 11:59 PM

## Objective

The objective of this introductory lab is to familiarize you with the system environment of C programs under Linux.

## Reading

Read chapter 1 from Kernighan&Ritchie (textbook). The introduction provides an overview of C programming. It is a bit dense. You are not expected to understand all the material. What you need to understand is the material discussed in class, with the textbook serving as a supplementary resource.

## Lecture Notes

- What is CS 240 about? ([lec1] [lec1])
- C programs and their system environment (see class notes) (additional reference: [lec2][lec2])
	- C code and machine code ([pdf][machineCode])
	- Roles of C compiler, C preprocessor, assembler, linker, loader
	- Reading and writing to standard I/O

[lec1]:https://github.com/sean8purdue/cs240ProgrammingInC/blob/lab1/lab1/cs240crisn1.pdf
[lec2]:https://github.com/sean8purdue/cs240ProgrammingInC/blob/lab1/lab1/cs240crisn2.pdf
[machineCode]:https://github.com/sean8purdue/cs240ProgrammingInC/blob/lab1/lab1/cs240-park1.pdf

## Lab1 code base

The C code base for lab1 is available as a tarball at 

`/u/data/u3/park/pub/cs240/lab1.tar `

on the Linux machines in LWSN B148. Copy it to your working directory and untar it using 

`% tar xvf lab1.tar `

Under lab1, you will find 7 subdirectories that contain versions of the example code discussed in class. As noted in class, always compile and run the final version on the pod machines in LWSN 148.

## Problems [145 pts]

### Problem1 (20 pts)

Compile the code in directory v1 by running 

`% gcc main.c `

What is the nature of the output a.out generated by gcc? What are the three steps performed by gcc that results in a.out? What does each of the steps accomplish? [Refer:JourneyOfaCProgramToLinuxExecutable](https://github.com/sean8purdue/cs240ProgrammingInC/blob/dev/lab1/JourneyOfaCProgramToLinuxExecutable.pdf)

1. The a.out genertated by gcc is an object code, it's an unlinked machine code(binary file).
2. There are four steps gcc performed.
	- First, it runs the C preprocessor to pre-	compile, ,output is **print.i** file.
	
		`$ gcc -Wall -E print.c `
		- expand all statements starting with #; 
		- Macro substitution;
		- Comments are stripped off 
	- Second, after the compiler is done with the pre-processor stage. The next step is to take print.i as input, compile it and produce an intermediate compiled output. The output file for this stage is ‘print.s’. The output present in print.s is assembly level instructions. output is **print.s** file. <br/><br/>
	- Third, at this stage the print.s file is taken as an input and an intermediate file print.o is produced. This file is also known as the object file. This file is produced by the assembler that understands and converts a ‘.s’ file with assembly instructions into a ‘.o’ object file which contains machine level instructions. <br/> At this stage only the existing code is converted into machine language, the function calls like printf() are not resolved. <br/><br/>
	- Fourth, Static Link and Dynamic Link. The linker comes into action at this stage and does this task. Generating a **executable file a.out**, or other programmer specified name. <br/> As discussed earlier, till this stage gcc doesn’t know about the definition of functions like printf(). Until the compiler knows exactly where all of these functions are implemented, it simply uses a place-holder for the function call. It is at this stage, the definition of printf() is resolved and the actual address of the function printf() is plugged in.

How does gcc react if you omit the type declaration of main()? Will gcc generate an executable? What happens if you declare main()'s type as void?

1. If omit the type declaration of main(), gcc will give warning when compile. But still generate **a.out** file.

	~~~bash
	main.c:6:1: warning: type specifier missing, defaults to 	'int'
   	   [-Wimplicit-int]
		main()
	^
	~~~

2. Delcare main() type as void, gcc warn:

	~~~bash
main.c:6:1: warning: return type of 'main' is not 'int'
      [-Wmain-return-type]
void main()
^
main.c:6:1: note: change return type to 'int'
void main()
^~~~
int
1 warning generated.
	~~~
	
### Problem2 (20 pts)

The version in directory v2 is essentially the same as the one in v1 except that printing of the addition result is facilitated by the libary function printf(). printf() outputs to standard output which is, by default, the terminal (i.e., display or screen) associated with a PC in our lab.

Where is the header file stdio.h located on our Linux lab machines in LWSN B148? 

`/usr/include`

What part of "result of %d + %d is %d" is literal (just characters to be printed as is) and what part is reserved, i.e., part of formatting control of C that determines how content of a variable is output? What happens if you run gcc with option -c? Can you execute the output generated by gcc? Explain.

1. "result of  + is" will be printed as is. %d will print as the content of a variable.
2. if run `gcc -c main.c`, we can just get `main.o` object file, which is not linked up to a executable file, so we cannot run it.

### Problem3 (30 pts)

The version of v3 makes a further enhancement such that the two numbers to be added are provided as input via keyboard input which, by default, is the standard input of a Linux PC. What is the role of & (i.e., ampersand) in 

`scanf("%d %d",&x,&y) `

and why is 

`scanf("%d %d",x,y) `

incorrect? Compile the code as is, and run it to verify that it works correctly. Modify the code by removing the two ampersands and compile main.c using gcc. What does gcc say after the modification? What happens when you run a.out? Explain.


1. The role of `&` is to get the address of variable.

2. Because `scanf("%d %d", x, y)' the argument are pointers(which contents are address).

3. removing ampersands will have warning:

	~~~c
	main.c:17:17: warning: format specifies type 'int *' but 	the argument
      has type 'int' [-Wformat]
  	scanf("%d %d",x,y);
         ~~     ^
	main.c:17:19: warning: format specifies type 'int *' but 	the argument
  	    has type 'int' [-Wformat]
 	 scanf("%d %d",x,y);
            ~~    ^
	2 warnings generated.
	~~~ 
4. Run a.out will have SEG fault, because we try to write to the memory address, which is not belonged to our process a.out. We input 99932, `scanf()` will try to write 99932 to the address 0, which is the value of x in this case. Since x is not defined, x might be other garbage value.

	~~~bash
	➜  v3 git:(lab1) ✗ ./a.out
99932
[1]    26574 segmentation fault  ./a.out
	~~~
	
	print the initial value of x, in this runtime, x is 1.

### Problem4 (20 pts)

Why does printf() in v3/main.c not use ampersand & before the variables x, y, z? What happens if you add & before the three local variables? Explain what gcc does and what happens when you execute the executable produced by gcc.

1. printf() pass arguments by value, not by address. So, there is no need to use ampersand before the variables.

2. It will give a warning when compile. But still generate executable file a.out. 

	~~~c
	main.c:25:34: warning: format specifies type 'int' but the argument
      has type 'int *' [-Wformat]
  printf("%d plus %d = %d\n", x, &y, z);
                  ~~             ^~
1 warning generated.
	~~~
3. When you execute a.out, it will get the address of y, instead of the value of y.

	~~~
	➜  v3 git:(lab1) ✗ ./a.out
3 2
3
3 plus 1358031336 = 5
	~~~

### Problem5 (40 pts)

v4 contains a floating point (i.e., real number) variation of v3. Compile and test with real numbers (say, 7.111 and 4.222) to check that it works correctly. In v5, the code is made more modular by implementing the addition part of the app code as a separate function, myadd(). Since myadd() is essentially a one-liner, the separation doesn't buy much in terms of clean design. However, the principle is clear: if the calculations were more involved, putting the instructions in a separate function makes the design more modular. myadd() takes the values to be added as its two arguments and returns the result to the calling function. Hence the caller is main() and the callee is myadd(). When passing the two arguments to myadd(), why do we not use ampersands, that is, myadd(&x,&y)? 

1. Because we want to pass by value, want the value of x, and y. Not the address.

Suppose instead of communicating to the caller the subtraction result using a function return, we want the callee to directly update the variable z in main() with the computed result. One way to do it is to change 

`z = myadd(x,y); `

to 

`myadd(x,y,&z); `

Why does adding &z as the third argument of myadd() enable the callee to update the value of variable z which belongs to main()? If this method of communicating between caller and callee is employed, C requires that the code of the callee be updated as follows: 

~~~
int myadd(float a, float b, float *c) { 
   *c = a + b; 
} 
~~~

The * symbol preceding argument c in the callee specifies that c contains an address (not value). Thus we are telling the callee myadd() where in RAM (i.e., memory) z is located, i.e., its address. Since the callee has this information, it can now, if it wants to, go to the address and update the content at that address. This is done by prepending c with * and performing the addition *c = a + b, instead of c = a + b. Make the modifications and compile the updated main.c. What does gcc say? What additional modification do we need to make to have a correct code? Figure it out on your own and if you get stuck the TAs will help. Since myadd() does not return a value, what type declaration can we assign myadd() to reflect/highlight this feature? Compile the updated code and test that it runs correctly.

2. Question: Why let myadd() return int?

